# 第三阶段：实例层调整 - 完成总结

## 完成时间
2025年12月26日

## 完成内容

### 1. DynamicTableManager重构 ✅

#### 1.1 表命名规则更新
- ✅ **新的表命名规则**：`instances_{class_id}`（使用UUID，去除连字符，替换为下划线）
  - 例如：`instances_550e8400_e29b_41d4_a716_446655440000`
- ✅ **添加 `getInstanceTableName(UUID)` 方法**：根据对象类型ID生成表名
- ✅ **保留向后兼容的 `tableExists(String)` 方法**（标记为 `@Deprecated`）

#### 1.2 方法签名更新
所有方法都添加了基于 `ObjectType` 或 `UUID` 的重载版本：

- ✅ `createInstanceTable(ObjectType, List<Property>)` - 使用对象类型ID生成表名
- ✅ `dropInstanceTable(ObjectType)` / `dropInstanceTable(UUID)` - 支持两种方式
- ✅ `tableExists(ObjectType)` / `tableExists(UUID)` - 新增基于ID的方法
- ✅ `addColumn(ObjectType, Property)` / `addColumn(UUID, Property)` - 新增基于ID的方法
- ✅ `dropColumn(ObjectType, String)` / `dropColumn(UUID, String)` - 新增基于ID的方法
- ✅ `hasColumnData(ObjectType, String)` / `hasColumnData(UUID, String)` - 新增基于ID的方法

#### 1.3 实例表结构更新
- ✅ **添加 `class_id` 字段**：每个实例表都包含 `class_id UUID NOT NULL` 字段，指向对象类型的ID
- ✅ **创建索引**：为 `class_id` 字段创建索引，提高查询性能
- ✅ **保留系统字段**：`id`, `created_at`, `updated_at`, `created_by`, `updated_by`

### 2. InstanceServiceImpl重构 ✅

#### 2.1 表名生成更新
- ✅ 所有方法都使用 `dynamicTableManager.getInstanceTableName(objectType.getId())` 生成表名
- ✅ 移除了硬编码的 `"instances_" + objectTypeName.toLowerCase()` 逻辑

#### 2.2 实例创建更新
- ✅ **插入 `class_id` 字段**：创建实例时，自动设置 `class_id = objectType.getId()`
- ✅ **查询时移除 `class_id`**：返回给前端的实例数据中，移除了 `class_id` 字段（内部字段）

#### 2.3 方法更新
- ✅ `createInstance` - 使用新的表名生成方法，插入class_id
- ✅ `updateInstance` - 使用新的表名生成方法
- ✅ `getInstance` - 使用新的表名生成方法，移除class_id字段
- ✅ `listInstances` - 使用新的表名生成方法，移除class_id字段
- ✅ `deleteInstance` - 使用新的表名生成方法
- ✅ `batchDeleteInstances` - 使用新的表名生成方法

### 3. PropertyServiceImpl更新 ✅

- ✅ `createProperty` - 使用 `tableExists(ObjectType)` 和 `addColumn(ObjectType, Property)`
- ✅ `deleteProperty` - 使用 `tableExists(ObjectType)`, `hasColumnData(ObjectType, String)`, `dropColumn(ObjectType, String)`

### 4. ObjectTypeServiceImpl更新 ✅

- ✅ `deleteObjectType` - 使用 `tableExists(ObjectType)` 和 `dropInstanceTable(ObjectType)`

## 核心改进

### 1. 使用UUID作为表名标识
- **优势**：
  - 避免表名冲突（即使对象类型名称相同，UUID也不同）
  - 对象类型重命名不影响表名
  - 更符合数据库设计规范（使用ID而非名称作为标识）

### 2. 添加class_id字段
- **优势**：
  - 便于跨表查询和关联
  - 支持实例的类型验证
  - 为未来的多租户或数据隔离预留空间

### 3. 向后兼容性
- 保留了基于 `String objectTypeName` 的方法（标记为 `@Deprecated`）
- 这些方法仍然可以工作，但会在日志中输出警告，提示使用新方法

## 数据库迁移说明

### 重要提示
由于表命名规则发生了变化（从 `instances_{name}` 改为 `instances_{uuid}`），**现有的实例表需要迁移**。

### 迁移步骤（建议）

1. **备份现有数据**
   ```sql
   -- 备份所有实例表
   pg_dump -t instances_* > instances_backup.sql
   ```

2. **创建迁移脚本**
   ```sql
   -- 为每个对象类型重命名表
   -- 例如：将 instances_user 重命名为 instances_550e8400_e29b_41d4_a716_446655440000
   ALTER TABLE instances_user RENAME TO instances_<object_type_id>;
   ```

3. **添加class_id字段**
   ```sql
   -- 为现有表添加class_id字段
   ALTER TABLE instances_<object_type_id> 
     ADD COLUMN class_id UUID NOT NULL DEFAULT '<object_type_id>';
   
   -- 创建索引
   CREATE INDEX idx_instances_<object_type_id>_class_id 
     ON instances_<object_type_id>(class_id);
   ```

4. **验证数据一致性**
   ```sql
   -- 检查所有实例表的class_id是否正确设置
   SELECT class_id, COUNT(*) FROM instances_<object_type_id> GROUP BY class_id;
   ```

### 自动迁移方案（可选）

可以创建一个迁移工具类，自动完成以下操作：
1. 查询所有对象类型
2. 查找对应的旧表名（`instances_{name}`）
3. 生成新表名（`instances_{uuid}`）
4. 重命名表
5. 添加class_id字段和索引
6. 验证迁移结果

## API使用说明

### 创建实例（自动设置class_id）
```json
POST /v1/object-types/{objectTypeName}/instances
{
  "properties": {
    "name": "张三",
    "age": 30
  }
}
```

响应中不会包含 `class_id` 字段（内部字段）。

### 查询实例列表
```json
GET /v1/object-types/{objectTypeName}/instances?current=1&size=10
```

响应中的实例数据不包含 `class_id` 字段。

## 待完善内容

### 1. 数据迁移脚本
- [ ] 创建自动化迁移脚本，将现有实例表从旧命名规则迁移到新命名规则
- [ ] 添加数据验证脚本，确保迁移后数据一致性
- [ ] 编写回滚脚本，以防迁移失败

### 2. LinkInstance表更新
- [ ] 考虑是否需要在 `link_instances` 表中也添加 `source_class_id` 和 `target_class_id` 字段
- [ ] 更新LinkInstanceService，使用class_id进行查询和验证

### 3. 查询性能优化
- [ ] 为 `class_id` 字段创建索引（已完成）
- [ ] 考虑为常用查询字段创建复合索引

### 4. 前端适配
- [ ] 前端无需修改（因为API响应不包含class_id字段）
- [ ] 但需要测试确保现有前端功能正常工作

## 文件清单

### 核心组件（已修改）
- `backend/src/main/java/com/example/datamodel/core/DynamicTableManager.java`
  - 更新表命名规则（使用UUID）
  - 添加基于ObjectType/UUID的方法重载
  - 添加class_id字段到实例表

### Service实现（已修改）
- `backend/src/main/java/com/example/datamodel/service/impl/InstanceServiceImpl.java`
  - 更新所有方法使用新的表名生成逻辑
  - 插入和查询时处理class_id字段

- `backend/src/main/java/com/example/datamodel/service/impl/PropertyServiceImpl.java`
  - 更新为使用新的DynamicTableManager方法

- `backend/src/main/java/com/example/datamodel/service/impl/ObjectTypeServiceImpl.java`
  - 更新为使用新的DynamicTableManager方法

## 测试建议

### 1. 单元测试
- [ ] 测试 `getInstanceTableName(UUID)` 方法生成正确的表名
- [ ] 测试实例创建时自动设置class_id
- [ ] 测试查询时移除class_id字段

### 2. 集成测试
- [ ] 测试创建对象类型 → 创建属性 → 创建实例的完整流程
- [ ] 测试实例的CRUD操作
- [ ] 测试对象类型重命名不影响实例表名

### 3. 数据迁移测试
- [ ] 测试表重命名脚本
- [ ] 测试添加class_id字段脚本
- [ ] 验证迁移后数据完整性

## 总结

第三阶段（实例层调整）已经完成，主要工作包括：

1. ✅ 更新DynamicTableManager使用UUID作为表名标识
2. ✅ 添加class_id字段到实例表结构
3. ✅ 更新InstanceService使用新的表名生成逻辑
4. ✅ 更新PropertyService和ObjectTypeService使用新的方法
5. ✅ 保持向后兼容性（保留旧方法，标记为@Deprecated）

系统现在具备了：
- 使用UUID作为表名标识，避免名称冲突
- 实例表中包含class_id字段，便于类型验证和查询
- 向后兼容的API，现有代码可以继续工作

下一步可以：
- 创建数据迁移脚本，将现有实例表迁移到新的命名规则
- 继续第四阶段（LinkInstance表更新）或第五阶段（前端适配）
- 或者先进行测试验证


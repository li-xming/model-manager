# 第三阶段：实例层调整 - 完整总结

## 完成时间
2025年12月26日

## 阶段目标
调整实例表创建逻辑，使用 `class_id`（UUID）作为表名标识，而非 `object_type_name`。

## 完成内容

### 1. DynamicTableManager重构 ✅

#### 1.1 表命名规则更新
- ✅ **新的表命名规则**：`instances_{class_id}`（使用UUID，去除连字符，替换为下划线）
  - 示例：`instances_550e8400_e29b_41d4_a716_446655440000`
- ✅ **添加 `getInstanceTableName(UUID)` 方法**：根据对象类型ID生成表名
- ✅ **保留向后兼容的 `tableExists(String)` 方法**（标记为 `@Deprecated`）

#### 1.2 方法签名更新
所有方法都添加了基于 `ObjectType` 或 `UUID` 的重载版本：

- ✅ `createInstanceTable(ObjectType, List<Property>)` - 使用对象类型ID生成表名
- ✅ `dropInstanceTable(ObjectType)` / `dropInstanceTable(UUID)` - 支持两种方式
- ✅ `tableExists(ObjectType)` / `tableExists(UUID)` - 新增基于ID的方法
- ✅ `addColumn(ObjectType, Property)` / `addColumn(UUID, Property)` - 新增基于ID的方法
- ✅ `dropColumn(ObjectType, String)` / `dropColumn(UUID, String)` - 新增基于ID的方法
- ✅ `hasColumnData(ObjectType, String)` / `hasColumnData(UUID, String)` - 新增基于ID的方法

#### 1.3 实例表结构更新
- ✅ **添加 `class_id` 字段**：每个实例表都包含 `class_id UUID NOT NULL` 字段，指向对象类型的ID
- ✅ **创建索引**：为 `class_id` 字段创建索引，提高查询性能
- ✅ **保留系统字段**：`id`, `created_at`, `updated_at`, `created_by`, `updated_by`

### 2. InstanceServiceImpl重构 ✅

#### 2.1 表名生成更新
- ✅ 所有方法都使用 `dynamicTableManager.getInstanceTableName(objectType.getId())` 生成表名
- ✅ 移除了硬编码的 `"instances_" + objectTypeName.toLowerCase()` 逻辑

#### 2.2 实例创建更新
- ✅ **插入 `class_id` 字段**：创建实例时，自动设置 `class_id = objectType.getId()`
- ✅ **查询时移除 `class_id`**：返回给前端的实例数据中，移除了 `class_id` 字段（内部字段）

#### 2.3 方法更新
- ✅ `createInstance` - 使用新的表名生成方法，插入class_id
- ✅ `updateInstance` - 使用新的表名生成方法
- ✅ `getInstance` - 使用新的表名生成方法，移除class_id字段
- ✅ `listInstances` - 使用新的表名生成方法，移除class_id字段
- ✅ `deleteInstance` - 使用新的表名生成方法
- ✅ `batchDeleteInstances` - 使用新的表名生成方法

### 3. PropertyServiceImpl更新 ✅

- ✅ `createProperty` - 使用 `tableExists(ObjectType)` 和 `addColumn(ObjectType, Property)`
- ✅ `deleteProperty` - 使用 `tableExists(ObjectType)`, `hasColumnData(ObjectType, String)`, `dropColumn(ObjectType, String)`

### 4. ObjectTypeServiceImpl更新 ✅

- ✅ `deleteObjectType` - 使用 `tableExists(ObjectType)` 和 `dropInstanceTable(ObjectType)`

### 5. LinkInstance表分析 ✅

- ✅ **分析结果**：LinkInstance表**无需修改**
- ✅ **原因**：
  - LinkInstance表存储的是实例ID（`source_instance_id`, `target_instance_id`），而不是对象类型名称
  - 对象类型信息通过LinkType获取（`linkType.getSourceObjectTypeId()`, `linkType.getTargetObjectTypeId()`）
  - 当前实现已经可以正常工作，无需添加class_id字段
  - 避免数据冗余，遵循数据库设计原则

## 核心改进

### 1. 使用UUID作为表名标识
- **优势**：
  - 避免表名冲突（即使对象类型名称相同，UUID也不同）
  - 对象类型重命名不影响表名
  - 更符合数据库设计规范（使用ID而非名称作为标识）

### 2. 添加class_id字段
- **优势**：
  - 便于跨表查询和关联
  - 支持实例的类型验证
  - 为未来的多租户或数据隔离预留空间

### 3. 向后兼容性
- 保留了基于 `String objectTypeName` 的方法（标记为 `@Deprecated`）
- 这些方法仍然可以工作，但会在日志中输出警告，提示使用新方法

## 数据库迁移说明

### 重要提示 ⚠️
由于表命名规则发生了变化（从 `instances_{name}` 改为 `instances_{uuid}`），**现有的实例表需要迁移**。

### 迁移步骤（建议）

1. **备份现有数据**
   ```sql
   -- 备份所有实例表
   pg_dump -t instances_* > instances_backup.sql
   ```

2. **创建迁移脚本**
   ```sql
   -- 为每个对象类型重命名表
   -- 例如：将 instances_user 重命名为 instances_550e8400_e29b_41d4_a716_446655440000
   DO $$
   DECLARE
       rec RECORD;
   BEGIN
       FOR rec IN 
           SELECT id, name FROM object_types
       LOOP
           EXECUTE format('ALTER TABLE IF EXISTS instances_%s RENAME TO instances_%s',
               lower(rec.name),
               replace(rec.id::text, '-', '_'));
       END LOOP;
   END $$;
   ```

3. **添加class_id字段**
   ```sql
   -- 为现有表添加class_id字段
   DO $$
   DECLARE
       rec RECORD;
       table_name TEXT;
   BEGIN
       FOR rec IN 
           SELECT id, name FROM object_types
       LOOP
           table_name := 'instances_' || replace(rec.id::text, '-', '_');
           EXECUTE format('ALTER TABLE %I ADD COLUMN IF NOT EXISTS class_id UUID NOT NULL DEFAULT %L',
               table_name, rec.id);
           EXECUTE format('CREATE INDEX IF NOT EXISTS idx_%s_class_id ON %I(class_id)',
               replace(rec.id::text, '-', '_'), table_name);
       END LOOP;
   END $$;
   ```

4. **验证数据一致性**
   ```sql
   -- 检查所有实例表的class_id是否正确设置
   DO $$
   DECLARE
       rec RECORD;
       table_name TEXT;
       count_val BIGINT;
   BEGIN
       FOR rec IN 
           SELECT id, name FROM object_types
       LOOP
           table_name := 'instances_' || replace(rec.id::text, '-', '_');
           EXECUTE format('SELECT COUNT(*) FROM %I WHERE class_id != %L',
               table_name, rec.id) INTO count_val;
           IF count_val > 0 THEN
               RAISE NOTICE 'Table % has % rows with incorrect class_id', table_name, count_val;
           END IF;
       END LOOP;
   END $$;
   ```

### 自动迁移方案（可选）

可以创建一个迁移工具类 `InstanceTableMigrationTool`，自动完成以下操作：
1. 查询所有对象类型
2. 查找对应的旧表名（`instances_{name}`）
3. 生成新表名（`instances_{uuid}`）
4. 重命名表
5. 添加class_id字段和索引
6. 验证迁移结果

## API使用说明

### 创建实例（自动设置class_id）
```json
POST /v1/object-types/{objectTypeName}/instances
{
  "properties": {
    "name": "张三",
    "age": 30
  }
}
```

响应中不会包含 `class_id` 字段（内部字段）。

### 查询实例列表
```json
GET /v1/object-types/{objectTypeName}/instances?current=1&size=10
```

响应中的实例数据不包含 `class_id` 字段。

## 文件清单

### 核心组件（已修改）
- `backend/src/main/java/com/example/datamodel/core/DynamicTableManager.java`
  - 更新表命名规则（使用UUID）
  - 添加基于ObjectType/UUID的方法重载
  - 添加class_id字段到实例表

### Service实现（已修改）
- `backend/src/main/java/com/example/datamodel/service/impl/InstanceServiceImpl.java`
  - 更新所有方法使用新的表名生成逻辑
  - 插入和查询时处理class_id字段

- `backend/src/main/java/com/example/datamodel/service/impl/PropertyServiceImpl.java`
  - 更新为使用新的DynamicTableManager方法

- `backend/src/main/java/com/example/datamodel/service/impl/ObjectTypeServiceImpl.java`
  - 更新为使用新的DynamicTableManager方法

### 分析文档（新增）
- `backend/第三阶段-LinkInstance分析.md`
  - LinkInstance表更新分析
  - 确认无需修改LinkInstance表

## 测试建议

### 1. 单元测试
- [ ] 测试 `getInstanceTableName(UUID)` 方法生成正确的表名
- [ ] 测试实例创建时自动设置class_id
- [ ] 测试查询时移除class_id字段
- [ ] 测试对象类型重命名不影响实例表名

### 2. 集成测试
- [ ] 测试创建对象类型 → 创建属性 → 创建实例的完整流程
- [ ] 测试实例的CRUD操作
- [ ] 测试属性添加/删除时实例表的更新
- [ ] 测试对象类型删除时实例表的删除

### 3. 数据迁移测试
- [ ] 测试表重命名脚本
- [ ] 测试添加class_id字段脚本
- [ ] 验证迁移后数据完整性
- [ ] 测试回滚脚本（如果需要）

## 总结

第三阶段（实例层调整）已经完成，主要工作包括：

1. ✅ 更新DynamicTableManager使用UUID作为表名标识
2. ✅ 添加class_id字段到实例表结构
3. ✅ 更新InstanceService使用新的表名生成逻辑
4. ✅ 更新PropertyService和ObjectTypeService使用新的方法
5. ✅ 分析LinkInstance表，确认无需修改
6. ✅ 保持向后兼容性（保留旧方法，标记为@Deprecated）

系统现在具备了：
- 使用UUID作为表名标识，避免名称冲突
- 实例表中包含class_id字段，便于类型验证和查询
- 向后兼容的API，现有代码可以继续工作

下一步可以：
- 创建数据迁移脚本，将现有实例表迁移到新的命名规则
- 进行测试验证
- 继续第四阶段（前端适配）或第五阶段（测试和优化）

